plotsignum(x,signum[,5],-1.96*sel,1.96*sel,-1.96*seu[5],1.96*seu[5])
title(main="alpha=0.50")
plotsignum(x,signum[,6],-1.96*sel,1.96*sel,-1.96*seu[6],1.96*seu[6])
title(main="alpha=0.75")
plotsignum(x,signum[,7],-1.96*sel,1.96*sel,-1.96*seu[7],1.96*seu[7])
title(main="alpha=0.90",ylab="Quantilogram",xlab = "Lag")
plotsignum(x,signum[,8],-1.96*sel,1.96*sel,-1.96*seu[8],1.96*seu[8])
title(main="alpha=0.95",xlab = "Lag")
plotsignum(x,signum[,9],-1.96*sel,1.96*sel,-1.96*seu[9],1.96*seu[9])
title(main="alpha=0.99",xlab = "Lag")
dev.copy(pdf,paste0("C:/Users/lmgv/iCloudDrive/SG MiQEF/MathStat/Ресерч/Quarterly data/New variables from Robert/dropped highly correlated vars/output/quantilogram/",
industry, ".pdf"))
dev.off()
}
firms <- read.csv(file="C:\\Users\\lmgv\\iCloudDrive\\SG MiQEF\\MathStat\\Ресерч\\Quarterly data\\New variables from Robert\\dropped highly correlated vars\\companies_with_full_obs.csv", header=TRUE, sep=",")
firms
for (i in firms){
print(i)
}
firms[:2
]
firms[:2]
firms[:2, ]
firms[1:2, ]
quantgram <- function(firm){
rr <- r[r[, "Security"] == firm,]
y <- rr[, 42]
y <- data.matrix(y)
n <- nrow(y)
nk <- 100
ll  <-  seq(from=1,by=1,length.out=nk)/nk
talpha  <-  as.matrix(c(0.01, 0.05, 0.10,0.25,0.5,0.75,0.90,0.95,0.99))
nalpha  <-  nrow(talpha)
sign_sign <- mat.or.vec(n,1)
signum <- mat.or.vec(nk,nalpha)
psignum <- mat.or.vec(nk,nalpha)
Vk <- mat.or.vec(nalpha,1)
seu <- mat.or.vec(nalpha,1)
bp <- mat.or.vec(nk,nalpha)
jalpha  <-  1
while (jalpha<=nalpha) {
alpha  <-  talpha[jalpha]
muhat <- quant(y,alpha)
epshat <-  y - muhat*as.matrix(rep(1,n))
check <- (epshat >0) - (epshat <0) -(1-2*alpha)*as.matrix(rep(1,n))
sign_sign <- as.matrix(mat.or.vec(n-1,1))
sign_sign <- check[1:(n-1)]*check[2:n]
signum[1,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-1)]^2)
a <- as.matrix(mat.or.vec(nk,1)) ;
k <- 2 ;
while (k<=nk){
sign_sign <- as.matrix(mat.or.vec(n-k,1))
sign_sign <- check[1:(n-k)]*check[(k+1):n]
signum[k,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-k)]^2)
a <- solve(toeplitz( c(1,signum[1:(k-1),jalpha])  ))%*%signum[1:k,jalpha]
psignum[k,jalpha] <- a[k] ;
k <- k+1 ;
}
Vk[jalpha] <- 1 +  ( max(  c(alpha,1-alpha))^2 )/(alpha*(1-alpha))
seu[jalpha] <- sqrt(Vk[jalpha]/n)
jalpha <- jalpha+1
}
msign <- signum[,5]
bp <- apply((signum^2),2,cumsum)
bpp <- apply((psignum^2),2,cumsum)
sel <- sqrt(1/n)
x <- ll*nk
par(mfrow=c(3,3),oma=c(1,1,1,1))
plotsignum(x,signum[,1],-1.96*sel,1.96*sel,-1.96*seu[1],1.96*seu[1])
title(main="alpha=0.01 ", ylab="Quantilogram")
plotsignum(x,signum[,2],-1.96*sel,1.96*sel,-1.96*seu[2],1.96*seu[2])
title(main="alpha=0.05")
plotsignum(x,a,-1.96*sel,1.96*sel,-1.96*seu[2],1.96*seu[2])
title(main="alpha=0.10")
plotsignum(x,signum[,4],-1.96*sel,1.96*sel,-1.96*seu[4],1.96*seu[4])
title(main="alpha=0.25",ylab="Quantilogram")
plotsignum(x,signum[,5],-1.96*sel,1.96*sel,-1.96*seu[5],1.96*seu[5])
title(main="alpha=0.50")
plotsignum(x,signum[,6],-1.96*sel,1.96*sel,-1.96*seu[6],1.96*seu[6])
title(main="alpha=0.75")
plotsignum(x,signum[,7],-1.96*sel,1.96*sel,-1.96*seu[7],1.96*seu[7])
title(main="alpha=0.90",ylab="Quantilogram",xlab = "Lag")
plotsignum(x,signum[,8],-1.96*sel,1.96*sel,-1.96*seu[8],1.96*seu[8])
title(main="alpha=0.95",xlab = "Lag")
plotsignum(x,signum[,9],-1.96*sel,1.96*sel,-1.96*seu[9],1.96*seu[9])
title(main="alpha=0.99",xlab = "Lag")
dev.copy(pdf,paste0("C:/Users/lmgv/iCloudDrive/SG MiQEF/MathStat/Ресерч/Quarterly data/New variables from Robert/dropped highly correlated vars/output/quantilogram/",
firm, ".pdf"))
dev.off()
}
for (i in firms[1:2, ]){
quantgram(i)
}
firms
quantgram("3M Co")
r[r[, "Security"] == "3M Co",]
r[r[, "Security"] == "3M Co",][, 42]
quantgram <- function(firm){
rr <- r[r[, "Security"] == firm,]
y <- rr[, 42]
y <- data.matrix(y)
n <- nrow(y)
nk <- 10
ll  <-  seq(from=1,by=1,length.out=nk)/nk
talpha  <-  as.matrix(c(0.01, 0.05, 0.10,0.25,0.5,0.75,0.90,0.95,0.99))
nalpha  <-  nrow(talpha)
sign_sign <- mat.or.vec(n,1)
signum <- mat.or.vec(nk,nalpha)
psignum <- mat.or.vec(nk,nalpha)
Vk <- mat.or.vec(nalpha,1)
seu <- mat.or.vec(nalpha,1)
bp <- mat.or.vec(nk,nalpha)
jalpha  <-  1
while (jalpha<=nalpha) {
alpha  <-  talpha[jalpha]
muhat <- quant(y,alpha)
epshat <-  y - muhat*as.matrix(rep(1,n))
check <- (epshat >0) - (epshat <0) -(1-2*alpha)*as.matrix(rep(1,n))
sign_sign <- as.matrix(mat.or.vec(n-1,1))
sign_sign <- check[1:(n-1)]*check[2:n]
signum[1,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-1)]^2)
a <- as.matrix(mat.or.vec(nk,1)) ;
k <- 2 ;
while (k<=nk){
sign_sign <- as.matrix(mat.or.vec(n-k,1))
sign_sign <- check[1:(n-k)]*check[(k+1):n]
signum[k,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-k)]^2)
a <- solve(toeplitz( c(1,signum[1:(k-1),jalpha])  ))%*%signum[1:k,jalpha]
psignum[k,jalpha] <- a[k] ;
k <- k+1 ;
}
Vk[jalpha] <- 1 +  ( max(  c(alpha,1-alpha))^2 )/(alpha*(1-alpha))
seu[jalpha] <- sqrt(Vk[jalpha]/n)
jalpha <- jalpha+1
}
msign <- signum[,5]
bp <- apply((signum^2),2,cumsum)
bpp <- apply((psignum^2),2,cumsum)
sel <- sqrt(1/n)
x <- ll*nk
par(mfrow=c(3,3),oma=c(1,1,1,1))
plotsignum(x,signum[,1],-1.96*sel,1.96*sel,-1.96*seu[1],1.96*seu[1])
title(main="alpha=0.01 ", ylab="Quantilogram")
plotsignum(x,signum[,2],-1.96*sel,1.96*sel,-1.96*seu[2],1.96*seu[2])
title(main="alpha=0.05")
plotsignum(x,a,-1.96*sel,1.96*sel,-1.96*seu[2],1.96*seu[2])
title(main="alpha=0.10")
plotsignum(x,signum[,4],-1.96*sel,1.96*sel,-1.96*seu[4],1.96*seu[4])
title(main="alpha=0.25",ylab="Quantilogram")
plotsignum(x,signum[,5],-1.96*sel,1.96*sel,-1.96*seu[5],1.96*seu[5])
title(main="alpha=0.50")
plotsignum(x,signum[,6],-1.96*sel,1.96*sel,-1.96*seu[6],1.96*seu[6])
title(main="alpha=0.75")
plotsignum(x,signum[,7],-1.96*sel,1.96*sel,-1.96*seu[7],1.96*seu[7])
title(main="alpha=0.90",ylab="Quantilogram",xlab = "Lag")
plotsignum(x,signum[,8],-1.96*sel,1.96*sel,-1.96*seu[8],1.96*seu[8])
title(main="alpha=0.95",xlab = "Lag")
plotsignum(x,signum[,9],-1.96*sel,1.96*sel,-1.96*seu[9],1.96*seu[9])
title(main="alpha=0.99",xlab = "Lag")
dev.copy(pdf,paste0("C:/Users/lmgv/iCloudDrive/SG MiQEF/MathStat/Ресерч/Quarterly data/New variables from Robert/dropped highly correlated vars/output/quantilogram/",
firm, ".pdf"))
dev.off()
}
quantgram("3M Co")
seq(from=1,by=1,length.out=5)/5
nrow(r[r[, "Security"] == "3M Co",][, 42])
nrow(data.matrix(r[r[, "Security"] == "3M Co",][, 42]))
talpha  <-  as.matrix(c(0.01, 0.05, 0.10,0.25,0.5,0.75,0.90,0.95,0.99))
rr <- r[r[, "Security"] == "3M Co",]
y <- rr[, 42]
y <- data.matrix(y)
n <- nrow(y)
nk <- 100
ll  <-  seq(from=1,by=1,length.out=nk)/nk
talpha  <-  as.matrix(c(0.01, 0.05, 0.10,0.25,0.5,0.75,0.90,0.95,0.99))
nalpha  <-  nrow(talpha)
sign_sign <- mat.or.vec(n,1)
signum <- mat.or.vec(nk,nalpha)
psignum <- mat.or.vec(nk,nalpha)
Vk <- mat.or.vec(nalpha,1)
seu <- mat.or.vec(nalpha,1)
bp <- mat.or.vec(nk,nalpha)
jalpha  <-  1
while (jalpha<=nalpha) {
alpha  <-  talpha[jalpha]
muhat <- quant(y,alpha)
epshat <-  y - muhat*as.matrix(rep(1,n))
check <- (epshat >0) - (epshat <0) -(1-2*alpha)*as.matrix(rep(1,n))
sign_sign <- as.matrix(mat.or.vec(n-1,1))
sign_sign <- check[1:(n-1)]*check[2:n]
signum[1,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-1)]^2)
a <- as.matrix(mat.or.vec(nk,1)) ;
k <- 2 ;
while (k<=nk){
sign_sign <- as.matrix(mat.or.vec(n-k,1))
sign_sign <- check[1:(n-k)]*check[(k+1):n]
signum[k,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-k)]^2)
a <- solve(toeplitz( c(1,signum[1:(k-1),jalpha])  ))%*%signum[1:k,jalpha]
psignum[k,jalpha] <- a[k] ;
k <- k+1 ;
}
Vk[jalpha] <- 1 +  ( max(  c(alpha,1-alpha))^2 )/(alpha*(1-alpha))
seu[jalpha] <- sqrt(Vk[jalpha]/n)
jalpha <- jalpha+1
}
?toeplitz
c(1,signum[1:(k-1),jalpha])
signum
sign_sign
check[1:(n-k)]
n-k
check[(k+1):n]
check
epshat
y
muhat
muhat
quant(y,alpha)
alpha
?quant
??quant
y
round(alpha*nrow(y))
(alpha*nrow(y))
sort(y)
?quantile
quantile(y, alpha)
quantgram <- function(firm){
rr <- r[r[, "Security"] == firm,]
y <- rr[, 42]
y <- data.matrix(y)
n <- nrow(y)
nk <- 100
ll  <-  seq(from=1,by=1,length.out=nk)/nk
talpha  <-  as.matrix(c(0.01, 0.05, 0.10,0.25,0.5,0.75,0.90,0.95,0.99))
nalpha  <-  nrow(talpha)
sign_sign <- mat.or.vec(n,1)
signum <- mat.or.vec(nk,nalpha)
psignum <- mat.or.vec(nk,nalpha)
Vk <- mat.or.vec(nalpha,1)
seu <- mat.or.vec(nalpha,1)
bp <- mat.or.vec(nk,nalpha)
jalpha  <-  1
while (jalpha<=nalpha) {
alpha  <-  talpha[jalpha]
muhat <- quantile(y,alpha)
epshat <-  y - muhat*as.matrix(rep(1,n))
check <- (epshat >0) - (epshat <0) -(1-2*alpha)*as.matrix(rep(1,n))
sign_sign <- as.matrix(mat.or.vec(n-1,1))
sign_sign <- check[1:(n-1)]*check[2:n]
signum[1,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-1)]^2)
a <- as.matrix(mat.or.vec(nk,1)) ;
k <- 2 ;
while (k<=nk){
sign_sign <- as.matrix(mat.or.vec(n-k,1))
sign_sign <- check[1:(n-k)]*check[(k+1):n]
signum[k,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-k)]^2)
a <- solve(toeplitz( c(1,signum[1:(k-1),jalpha])  ))%*%signum[1:k,jalpha]
psignum[k,jalpha] <- a[k] ;
k <- k+1 ;
}
Vk[jalpha] <- 1 +  ( max(  c(alpha,1-alpha))^2 )/(alpha*(1-alpha))
seu[jalpha] <- sqrt(Vk[jalpha]/n)
jalpha <- jalpha+1
}
msign <- signum[,5]
bp <- apply((signum^2),2,cumsum)
bpp <- apply((psignum^2),2,cumsum)
sel <- sqrt(1/n)
x <- ll*nk
par(mfrow=c(3,3),oma=c(1,1,1,1))
plotsignum(x,signum[,1],-1.96*sel,1.96*sel,-1.96*seu[1],1.96*seu[1])
title(main="alpha=0.01 ", ylab="Quantilogram")
plotsignum(x,signum[,2],-1.96*sel,1.96*sel,-1.96*seu[2],1.96*seu[2])
title(main="alpha=0.05")
plotsignum(x,a,-1.96*sel,1.96*sel,-1.96*seu[2],1.96*seu[2])
title(main="alpha=0.10")
plotsignum(x,signum[,4],-1.96*sel,1.96*sel,-1.96*seu[4],1.96*seu[4])
title(main="alpha=0.25",ylab="Quantilogram")
plotsignum(x,signum[,5],-1.96*sel,1.96*sel,-1.96*seu[5],1.96*seu[5])
title(main="alpha=0.50")
plotsignum(x,signum[,6],-1.96*sel,1.96*sel,-1.96*seu[6],1.96*seu[6])
title(main="alpha=0.75")
plotsignum(x,signum[,7],-1.96*sel,1.96*sel,-1.96*seu[7],1.96*seu[7])
title(main="alpha=0.90",ylab="Quantilogram",xlab = "Lag")
plotsignum(x,signum[,8],-1.96*sel,1.96*sel,-1.96*seu[8],1.96*seu[8])
title(main="alpha=0.95",xlab = "Lag")
plotsignum(x,signum[,9],-1.96*sel,1.96*sel,-1.96*seu[9],1.96*seu[9])
title(main="alpha=0.99",xlab = "Lag")
dev.copy(pdf,paste0("C:/Users/lmgv/iCloudDrive/SG MiQEF/MathStat/Ресерч/Quarterly data/New variables from Robert/dropped highly correlated vars/output/quantilogram/",
firm, ".pdf"))
dev.off()
}
quantgram("3M Co")
y <- rr[, 42]
y <- data.matrix(y)
n <- nrow(y)
nk <- 100
ll  <-  seq(from=1,by=1,length.out=nk)/nk
talpha  <-  as.matrix(c(0.01, 0.05, 0.10,0.25,0.5,0.75,0.90,0.95,0.99))
nalpha  <-  nrow(talpha)
sign_sign <- mat.or.vec(n,1)
signum <- mat.or.vec(nk,nalpha)
psignum <- mat.or.vec(nk,nalpha)
Vk <- mat.or.vec(nalpha,1)
seu <- mat.or.vec(nalpha,1)
bp <- mat.or.vec(nk,nalpha)
jalpha  <-  1
while (jalpha<=nalpha) {
alpha  <-  talpha[jalpha]
muhat <- quantile(y,alpha)
epshat <-  y - muhat*as.matrix(rep(1,n))
check <- (epshat >0) - (epshat <0) -(1-2*alpha)*as.matrix(rep(1,n))
sign_sign <- as.matrix(mat.or.vec(n-1,1))
sign_sign <- check[1:(n-1)]*check[2:n]
signum[1,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-1)]^2)
a <- as.matrix(mat.or.vec(nk,1)) ;
k <- 2 ;
while (k<=nk){
sign_sign <- as.matrix(mat.or.vec(n-k,1))
sign_sign <- check[1:(n-k)]*check[(k+1):n]
signum[k,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-k)]^2)
a <- solve(toeplitz( c(1,signum[1:(k-1),jalpha])  ))%*%signum[1:k,jalpha]
psignum[k,jalpha] <- a[k] ;
k <- k+1 ;
}
Vk[jalpha] <- 1 +  ( max(  c(alpha,1-alpha))^2 )/(alpha*(1-alpha))
seu[jalpha] <- sqrt(Vk[jalpha]/n)
jalpha <- jalpha+1
}
alpha  <-  talpha[jalpha]
muhat <- quantile(y,alpha)
epshat <-  y - muhat*as.matrix(rep(1,n))
check <- (epshat >0) - (epshat <0) -(1-2*alpha)*as.matrix(rep(1,n))
sign_sign <- as.matrix(mat.or.vec(n-1,1))
sign_sign <- check[1:(n-1)]*check[2:n]
signum[1,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-1)]^2)
a <- as.matrix(mat.or.vec(nk,1)) ;
k <- 2 ;
while (k<=nk){
sign_sign <- as.matrix(mat.or.vec(n-k,1))
sign_sign <- check[1:(n-k)]*check[(k+1):n]
signum[k,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-k)]^2)
a <- solve(toeplitz( c(1,signum[1:(k-1),jalpha])  ))%*%signum[1:k,jalpha]
psignum[k,jalpha] <- a[k] ;
k <- k+1 ;
}
k
nk
sign_sign <- as.matrix(mat.or.vec(n-k,1))
mat.or.vec(n-k,1)
n-k
n
k
quantgram <- function(firm){
rr <- r[r[, "Security"] == firm,]
y <- rr[, 42]
y <- data.matrix(y)
n <- nrow(y)
nk <- n
ll  <-  seq(from=1,by=1,length.out=nk)/nk
talpha  <-  as.matrix(c(0.01, 0.05, 0.10,0.25,0.5,0.75,0.90,0.95,0.99))
nalpha  <-  nrow(talpha)
sign_sign <- mat.or.vec(n,1)
signum <- mat.or.vec(nk,nalpha)
psignum <- mat.or.vec(nk,nalpha)
Vk <- mat.or.vec(nalpha,1)
seu <- mat.or.vec(nalpha,1)
bp <- mat.or.vec(nk,nalpha)
jalpha  <-  1
while (jalpha<=nalpha) {
alpha  <-  talpha[jalpha]
muhat <- quantile(y,alpha)
epshat <-  y - muhat*as.matrix(rep(1,n))
check <- (epshat >0) - (epshat <0) -(1-2*alpha)*as.matrix(rep(1,n))
sign_sign <- as.matrix(mat.or.vec(n-1,1))
sign_sign <- check[1:(n-1)]*check[2:n]
signum[1,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-1)]^2)
a <- as.matrix(mat.or.vec(nk,1)) ;
k <- 2 ;
while (k<=nk){
sign_sign <- as.matrix(mat.or.vec(n-k,1))
sign_sign <- check[1:(n-k)]*check[(k+1):n]
signum[k,jalpha]  <-  mean(sign_sign)/mean(check[1:(n-k)]^2)
a <- solve(toeplitz( c(1,signum[1:(k-1),jalpha])  ))%*%signum[1:k,jalpha]
psignum[k,jalpha] <- a[k] ;
k <- k+1 ;
}
Vk[jalpha] <- 1 +  ( max(  c(alpha,1-alpha))^2 )/(alpha*(1-alpha))
seu[jalpha] <- sqrt(Vk[jalpha]/n)
jalpha <- jalpha+1
}
msign <- signum[,5]
bp <- apply((signum^2),2,cumsum)
bpp <- apply((psignum^2),2,cumsum)
sel <- sqrt(1/n)
x <- ll*nk
par(mfrow=c(3,3),oma=c(1,1,1,1))
plotsignum(x,signum[,1],-1.96*sel,1.96*sel,-1.96*seu[1],1.96*seu[1])
title(main="alpha=0.01 ", ylab="Quantilogram")
plotsignum(x,signum[,2],-1.96*sel,1.96*sel,-1.96*seu[2],1.96*seu[2])
title(main="alpha=0.05")
plotsignum(x,a,-1.96*sel,1.96*sel,-1.96*seu[2],1.96*seu[2])
title(main="alpha=0.10")
plotsignum(x,signum[,4],-1.96*sel,1.96*sel,-1.96*seu[4],1.96*seu[4])
title(main="alpha=0.25",ylab="Quantilogram")
plotsignum(x,signum[,5],-1.96*sel,1.96*sel,-1.96*seu[5],1.96*seu[5])
title(main="alpha=0.50")
plotsignum(x,signum[,6],-1.96*sel,1.96*sel,-1.96*seu[6],1.96*seu[6])
title(main="alpha=0.75")
plotsignum(x,signum[,7],-1.96*sel,1.96*sel,-1.96*seu[7],1.96*seu[7])
title(main="alpha=0.90",ylab="Quantilogram",xlab = "Lag")
plotsignum(x,signum[,8],-1.96*sel,1.96*sel,-1.96*seu[8],1.96*seu[8])
title(main="alpha=0.95",xlab = "Lag")
plotsignum(x,signum[,9],-1.96*sel,1.96*sel,-1.96*seu[9],1.96*seu[9])
title(main="alpha=0.99",xlab = "Lag")
dev.copy(pdf,paste0("C:/Users/lmgv/iCloudDrive/SG MiQEF/MathStat/Ресерч/Quarterly data/New variables from Robert/dropped highly correlated vars/output/quantilogram/",
firm, ".pdf"))
dev.off()
}
quantgram("3M Co")
quantgram("3M Co")
signum[1:(k - 1), jalpha]
c(1,signum[1:(k-1),jalpha])
jalpha
1:(k-1)
signum
sign_sign
n-1
check
#### MVAdiscbh ####
setwd('C:/Users/lmgv/iCloudDrive/SG MiQEF/MathStat/MVA codes/MVAdiscbh')
data = read.table("bostonh.dat")
# transform data
xt        = data
xt[, 1]   = log(data[, 1])
xt[, 2]   = data[, 2]/10
xt[, 3]   = log(data[, 3])
xt[, 5]   = log(data[, 5])
xt[, 6]   = log(data[, 6])
xt[, 7]   = (data[, 7]^(2.5))/10000
xt[, 8]   = log(data[, 8])
xt[, 9]   = log(data[, 9])
xt[, 10]  = log(data[, 10])
xt[, 11]  = exp(0.4 * data[, 11])/1000
xt[, 12]  = data[, 12]/100
xt[, 13]  = sqrt(data[, 13])
xt[, 14]  = log(data[, 14])
data      = xt[, -4]
da    = scale(data)                     # standardize variables
d     = dist(da, "euclidean", p = 2)    # euclidean distance matrix
w     = hclust(d, method = "ward.D")    # cluster analysis with ward algorithm
tree  = cutree(w, 2)                    # define the clusters, tree=1 if cluster=1
# the following two lines under comments are for price of Boston houses
# tree=(xt[,14]>median(xt[,14]))+1
# da=da[,1:12]
t1  = subset(da, tree == 1)
t2  = subset(da, tree == 2)
m1  = colMeans(t1)                      # mean of first cluster
m2  = colMeans(t2)                      # mean of second cluster
m   = (m1 + m2)/2                       # mean of both clusters
s = ((nrow(t1) - 1) * cov(t1) + (nrow(t2) - 1) * cov(t2))/(nrow(xt) - 2)    # common variance matrix
alpha = solve(s) %*% (m1 - m2)                                              # alpha for the discrimination rule
# APER for clusters of Boston houses
mis1  = sum((t1 - m) %*% alpha < 0)     # misclassified 1
mis2  = sum((t2 - m) %*% alpha > 0)     # misclassified 2
corr1 = sum((t1 - m) %*% alpha > 0)     # correct 1
corr2 = sum((t2 - m) %*% alpha < 0)     # correct 2
aper  = (mis1 + mis2)/nrow(xt)          # APER (apparent error rate)
alph  = (da - matrix(m, nrow(da), ncol(da), byrow = T)) %*% alpha
set.seed(1)
alph
head(aalph
head(alph)
p = cbind(alph, tree + 0.05 * rnorm(NROW(tree)))
p
?rnorm
NROW(tree)
tree[tree == 1] = 16
tree[tree == 2] = 17
tr = tree
tr[tr == 16] = "red"
tr[tr == 17] = "black"
# plot of discrimination scores
plot(p[, 1], p[, 2], pch = tree, col = tr, xaxt = "n", yaxt = "n", xlab = "", ylab = "",
bty = "n")
abline(v = 0, lwd = 3)
title(paste("Discrimination scores"))
p
tree + 0.05 * rnorm(NROW(tree))
setwd('C:/Users/lmgv/iCloudDrive/SG MiQEF/MathStat/MVA codes/MVAaerbh')
data = read.table("bostonh.dat")
# transform data
xt        = data
xt[, 1]   = log(data[, 1])
xt[, 2]   = data[, 2]/10
xt[, 3]   = log(data[, 3])
xt[, 5]   = log(data[, 5])
xt[, 6]   = log(data[, 6])
xt[, 7]   = (data[, 7]^(2.5))/10000
xt[, 8]   = log(data[, 8])
xt[, 9]   = log(data[, 9])
xt[, 10]  = log(data[, 10])
xt[, 11]  = exp(0.4 * data[, 11])/1000
xt[, 12]  = data[, 12]/100
xt[, 13]  = sqrt(data[, 13])
xt[, 14]  = log(as.numeric(data[, 14]))
data      = xt[, -4]
da    = scale(data)                     # standardize variables
d     = dist(da, "euclidean", p = 2)    # euclidean distance matrix
w     = hclust(d, method = "ward.D")    # cluster analysis with ward algorithm
tree  = cutree(w, 2)
